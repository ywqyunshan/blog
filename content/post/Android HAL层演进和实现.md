---
layout:     post

title:      "Android HAL层演进和实现"
subtitle:   ""
excerpt: ""
author:     "iigeoywq button"
date:       2024-03-02
published: true 
tags:
    - 工程实战

categories: [ Tech ]
URL: "/2024/03/02"
---
## 一 Android HAL层解决了什么问题？

Android的HAL层解决了什么问题？
* HAL层向下屏蔽硬件实现，向上提供抽象接口，和所有的其他系统一样，提供硬件接口抽象层；
* 解决了Linux 开源协议问题，保护了厂商的利益；

![Android HAL层实现方案](/img/hal.png)

## 二 Android HAL层接口演进

Android HAL层接口经历了3个阶段



| 接口       | 系统版本     | 说明           | 接口定义                                                                       |
| -------- | -------- | ------------ | -------------------------------------------------------------------------- |
| 传统接口     | 4.4-7.0  | C风格接口        | https://source.android.com/reference/hal?hl=zh-cn                          |
| HIDL     | 8.0-10.0 | C++风格接口      | https://source.android.com/docs/core/architecture/hidl/code-style?hl=zh-cn |
| HAL-AIDL | 11.0-至今  | Android 风格接口 | https://source.android.com/docs/core/architecture/aidl/aidl-hals?hl=zh-cn  |



* HIDL接口为了解耦Framework和vendor，这样当更新Framework时候不用编译hal层，hal层实现可以由厂商单独编译在vendor分区更新；

* AIDL接口为了减少Android的binder通信通道；


先简单介绍一下这三种接口规范：
* 传统接口定义规范
hardware/libhardware/include/hardware/hardware.h

```
struct hw_module_t; //硬件模块名
struct hw_module_methods_t; //硬件模块方法名
struct hw_device_t;//硬件设备名称
```
* HIDL接口定义规范
hardware/interfaces/foo/1.0/IFoo.hal
```

/*
 * (License Notice)
 */

package android.hardware.foo@1.0;

import android.hardware.bar@1.0::IBar;

import IBaz;
import IFooClientCallback;

/**
 * IFoo is an interface that…
 */
interface IFoo {

    foo() generates (FooStatus result);

    powerCycle(IBar bar) generates (FooStatus result);

    /** Single line docstring. */
    baz();

    bar(IFooClientCallback clientCallback,
        IBaz baz,
        FooData data);

};
```
* HAD-AIDL接口定义规范
hardware/interfaces/foo/aidl/IFoo.aidl
```
    package my.package;

    import my.package.Baz; // defined elsewhere

    interface IFoo {
        void doFoo(Baz baz);
    }
```
## 三 Android HAL层接口和实现兼容
每个版本上hal层的新增模块要用新接口规范，但是还存在兼容旧版本问题，所以关于hal层的实现有5种实现方案。

![Hal层的五种实现方式](/img/hal五种实现.png)

## 四 Android HIDL和AIDL实战
着重实现一个上图种的第4和5方式


### 4.1 HIDL实现
* 注意：新增hidl服务，需要使用android11以下系统，android11及以上不支持新增hidl接口，会报错
```
error: hardware/interfaces/testhidl/1.0/Android.bp:4:9: module "android.hardware.testhidl@1.0_interface": name: No more HIDL interfaces can be added to Android. Please use AIDL.
```

AOSP开源代码接口定义在hardware/interfaces/
基线厂商或者手机厂商的定制ROM 可能定义在vendor/xxx/hardware/interfaces/

下面添加一个testhidl hal模块
#### 4.1.1 定义接口
在hardware/interfaces/下创建testhidl/1.0/
并创建接口文件ITesthidl.hal
```

package android.hardware.testhidl@1.0;

interface ITesthidl {

    setInfo(Info info) generates (Error error);
};

```
type.hal
非必要，定义结构体
```
package android.hardware.testhidl@1.0;

/** Return codes from all functions. */
enum Error : int32_t {
    NONE            = 0, /* no error */
    BAD             = 1, /* bad */
};

typedef uint64_t Info;
```
#### 4.1.2 使用hidl-gen自动生成代码

* 生成hidl interface android.bp 文件
先确保AOSP全编译通过

```
source build/envsetup.sh
lunch xx
m hidk-gen
./hardware/interfaces/update-makefiles.sh
```
生成的Andoid.bp 文件,目录：/hardware/interfaces/testhidl/1.0/Andoid.bp
如下；
```
// This file is autogenerated by hidl-gen -Landroidbp.

hidl_interface {
    name: "android.hardware.testhidl@1.0",
    root: "android.hardware",
    srcs: [
        "types.hal",
        "ITesthidl.hal",
    ],
    interfaces: [
        "android.hidl.base@1.0",
    ],
    gen_java: true,
}
```
* 生成hal service的实现类
```
# 执行命令
hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport $PACKAGE
```

生成hal service的类，目录：/hardware/interfaces/testhidl/1.0/default/Testhidl.h
如下
头文件:Testhidl.h
```
// FIXME: your file license if you have one

#pragma once

#include <android/hardware/testhidl/1.0/ITesthidl.h>
#include <hidl/MQDescriptor.h>
#include <hidl/Status.h>

namespace android::hardware::testhidl::implementation {

using ::android::hardware::hidl_array;
using ::android::hardware::hidl_memory;
using ::android::hardware::hidl_string;
using ::android::hardware::hidl_vec;
using ::android::hardware::Return;
using ::android::hardware::Void;
using ::android::sp;

struct Testhidl : public V1_0::ITesthidl {
    // Methods from ::android::hardware::testhidl::V1_0::ITesthidl follow.
    Return<::android::hardware::testhidl::V1_0::Error> setInfo(uint64_t info) override;

    // Methods from ::android::hidl::base::V1_0::IBase follow.

};

// FIXME: most likely delete, this is only for passthrough implementations
// extern "C" ITesthidl* HIDL_FETCH_ITesthidl(const char* name);

}  // namespace android::hardware::testxidl::implementation
```
实现类，目录：/hardware/interfaces/testhidl/1.0/default/Testhidl.cpp
Testhidl.cpp
```
// FIXME: your file license if you have one

#include "Testhidl.h"

namespace android::hardware::testhidl::implementation {

// Methods from ::android::hardware::testhidl::V1_0::ITesthidl follow.
Return<::android::hardware::testhidl::V1_0::Error> Testhidl::setInfo(uint64_t info) {
    // TODO implement
    return ::android::hardware::testhidl::V1_0::Error {};
}


// Methods from ::android::hidl::base::V1_0::IBase follow.

//ITesthidl* HIDL_FETCH_ITesthidl(const char* /* name */) {
    //return new Testhidl();
//}
//
}  // namespace android::hardware::testhidl::implementation
```

* 生成hal service 的android.bp 文件


```
# 执行命令
PACKAGE=android.hardware.testhidl@1.0
LOC=hardware/interfaces/testhidl/1.0/default/
```
生成的hal service Andorid.bp 文件如下
目录hardware/interfaces/testhidl/1.0/default/Andorid.bp
```
// FIXME: your file license if you have one

cc_binary {
    // FIXME: this should only be -impl for a passthrough hal.
    // In most cases, to convert this to a binderized implementation, you should:
    // - change '-impl' to '-service' here and make it a cc_binary instead of a
    //   cc_library_shared.
    // - add a *.rc file for this module.
    // - delete HIDL_FETCH_I* functions.
    // - call configureRpcThreadpool and registerAsService on the instance.
    // You may also want to append '-impl/-service' with a specific identifier like
    // '-vendor' or '-<hardware identifier>' etc to distinguish it.
    name: "android.hardware.testhidl@1.0-service",
    relative_install_path: "hw",
    // FIXME: this should be 'vendor: true' for modules that will eventually be
    // on AOSP.
    init_rc: ["android.hardware.testhidl@1.0-service.rc"],
    defaults: ["hidl_defaults"],
    proprietary: true, //声明别安装在vendor目录
    srcs: [
        "Testhidl.cpp",
        "service.cpp"
    ],
    shared_libs: [
        "libhidlbase",
        "libutils",
        "libhidltransport",
        "android.hardware.testxidl@1.0",
    ],
}
```

#### 4.1.3 开启自启动
* 创建自启动的service.cpp
```

#define LOG_TAG "android.hardware.testhidl@1.0-service"

#include <sched.h>

#include <android/hardware/testhidl/1.0/ITesthidl.h>

#include <hidl/LegacySupport.h>
using android::hardware::testhidl::V1_0::implementation::Testhidl;

using android::hardware::testhidl::V1_0::ITesthidl;

int main() {

    ALOGE("testhidl service main");

    android::hardware::configureRpcThreadpool(4, true /* will join */);
    android::sp<ITesthidl> testhidl = new Testhidl();
    if (testhidl == nullptr) {
        return 1;
    }
    if (testhidl->registerAsService() != android::NO_ERROR) {
        ALOGE("failed to register service");
        return 1;
    }

    android::hardware::joinRpcThreadpool();

    ALOGE("testhidl service is terminating");
    return 1;
}
```
* 创建启动的rc
在default目录下创建android.hardware.testhidl@1.0-service.rc文件
```
service vendor.testhidl-1-0 /vendor/bin/hw/android.hardware.testhidl@1.0-service
    interface android.hardware.testhidl@1.0::ITesthidl default
    class hal 
    user system
    group system
     seclabel u:r:su:s0
```

#### 4.1.4 注释hal-manifest.xml
根据厂商的设备目录，下面是goldfish 设备
device/generic/goldfish/manifest.xml
```
<hal format="hidl">
    <name>android.hardware.testhidl</name>
    <transport>hwbinder</transport>
    <version>1.0</version>
    <interface>
        <name>ITesthidl</name>
        <instance>default</instance>
    </interface>
</hal>

```

#### 4.1.5 编译
* 声明product
device/generic/goldfish/minimal_system.mk
```
PRODUCT_PACKAGES += \\
    android.hardware.testhidl@1.0-service
```

* mmm ./hardware/interface/testhidl/1.0

service输出的可执行目录：
/out/target/product/xxx/vendor/bin/hw/
android.hardware.testhidl@1.0-service


## 4.2 AIDL实现
todo待验证



